// based on the Dodecahedron Wikipedia article: https://en.wikipedia.org/wiki/Dodecahedron#Cartesian_coordinates

//h = 0; // cube
//h = 1; // rhombic dodecahedron
h = 0.5*(sqrt(5)-1); // dodecahedron
//h = 0.5*(-sqrt(5)-1); // great stellated dodecahedron
//h = 0.5; // natural pyrite

VR = 0.2; // vertex radius
RT = 0.2; // rod thickness

$fn=120;

// Dodecahedron
//C = [ [1,1,1],[1,1,-1],[1,-1,1],[1,-1,-1], [-1,1,1],[-1,1,-1],[-1,-1,1],[-1,-1,-1], [0,1+h,1-h*h], [0,1+h,-1+h*h],  [0,-1-h,1-h*h], [0,-1-h,-1+h*h], [1+h,1-h*h,0], [1+h,-1+h*h,0],  [-1-h,1-h*h,0], [-1-h,-1+h*h,0], [1-h*h,0,1+h], [-1+h*h,0,1+h],  [1-h*h,0,-1-h], [-1+h*h,0,-1-h] ];
 // Icosahedron
//C = [[-1.17082039, 0.0, -0.7236068],[-1.17082039, 0.0, 0.7236068], [-0.7236068, -1.17082039, 0.0],[-0.7236068, 1.17082039, 0.0],[0.0, -0.7236068, -1.17082039],[0.0, -0.7236068, 1.17082039],[0.0, 0.7236068, -1.17082039],[0.0, 0.7236068, 1.17082039],[0.7236068, -1.17082039, 0.0],[0.7236068, 1.17082039, 0.0],[1.17082039, 0.0, -0.7236068],[1.17082039, 0.0, 0.7236068]];

// Cube
//C = [[1,1,1], [1,1,-1], [1,-1,1], [1,-1,-1], [-1,1,1], [-1,1,-1], [-1,-1,1], [-1,-1,-1]];

// Octahedron
//C = [[1,0,0], [0,1,0], [0,0,1], [-1,0,0], [0,-1,0], [0,0,-1]];

//Tetrahedron
C = [[1,1,-1], [1,-1,1], [-1,1,1], [-1,-1,-1]];

// minimum distance between vertices
DM = [ for ( i = [0:len(C)-2] ) for ( j = [i+1:len(C)-1] )
    sqrt((C[i]-C[j])*(C[i]-C[j])) ];
minD = min(DM)+0.1;

// edge list
EL = [for ( i = [0:len(C)-2] ) for ( j = [i+1:len(C)-1]) 
    if (sqrt( (C[i]-C[j])*(C[i]-C[j])) < minD ) [ i, j ]
        ];
 
intersection(){    
union(){
    // RODS
    for ( i = [0:len(C)-2] ) for ( j = [i+1:len(C)-1]) {
    V = C[i]-C[j];
    if (sqrt(V*V) < minD ) {
            rod(C[i], C[j], RT);
    }
    }
    // SPHERES
    for ( i = [0:len(C)-1] )
    {
    if (i < 8)  color([0.5,0.5,0.5]) translate(C[i]) sphere(r=VR);
      else translate(C[i]) sphere(r=VR);    
    }
    }
hull() 
    // Dodecahedron
    //polyhedron(points=[[1.0, 1.0, 1.0], [1.0, 1.0, -1.0], [1.0, -1.0, 1.0], [1.0, -1.0, -1.0], [-1.0, 1.0, 1.0], [-1.0, 1.0, -1.0], [-1.0, -1.0, 1.0], [-1.0, -1.0, -1.0], [0.0, 1.618033988749895, 0.6180339887498948], [0.0, 1.618033988749895, -0.6180339887498948], [0.0, -1.618033988749895, 0.6180339887498948], [0.0, -1.618033988749895, -0.6180339887498948], [1.618033988749895, 0.6180339887498948, 0.0], [1.618033988749895, -0.6180339887498948, 0.0], [-1.618033988749895, 0.6180339887498948, 0.0], [-1.618033988749895, -0.6180339887498948, 0.0], [0.6180339887498948, 0.0, 1.618033988749895], [-0.6180339887498948, 0.0, 1.618033988749895], [0.6180339887498948, 0.0, -1.618033988749895], [-0.6180339887498948, 0.0, -1.618033988749895]], faces=[[0, 12, 1, 9, 8], [0, 16, 17, 4, 8], [0, 16, 2, 13, 12], [1, 18, 19, 5, 9], [1, 18, 3, 13, 12], [2, 13, 3, 11, 10], [2, 16, 17, 6, 10], [3, 18, 19, 7, 11], [4, 14, 5, 9, 8], [4, 17, 6, 15, 14], [5, 19, 7, 15, 14], [6, 15, 7, 11, 10]]);
    // Icosahedron
   //polyhedron(points=[[-1.17082039, 0.0, -0.7236068], [-1.17082039, 0.0, 0.7236068], [-0.7236068, -1.17082039, 0.0], [-0.7236068, 1.17082039, 0.0], [0.0, -0.7236068, -1.17082039], [0.0, -0.7236068, 1.17082039], [0.0, 0.7236068, -1.17082039], [0.0, 0.7236068, 1.17082039], [0.7236068, -1.17082039, 0.0], [0.7236068, 1.17082039, 0.0], [1.17082039, 0.0, -0.7236068], [1.17082039, 0.0, 0.7236068]], faces=[[0, 2, 1], [0, 3, 1], [0, 4, 2], [0, 6, 3], [0, 6, 4], [1, 5, 2], [1, 7, 3], [1, 7, 5], [2, 8, 4], [2, 8, 5], [3, 9, 6], [3, 9, 7], [4, 10, 6], [4, 10, 8], [5, 11, 7], [5, 11, 8], [6, 10, 9], [7, 11, 9], [8, 11, 10], [9, 11, 10]]);
 // cube
 //   polyhedron(points=[[1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1], [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1]], faces=[[0, 2, 3, 1], [0, 4, 5, 1], [0, 4, 6, 2], [1, 5, 7, 3], [2, 6, 7, 3], [4, 6, 7, 5]]);
//octohedron
//    polyhedron(points=[[1, 0, 0], [0, 1, 0], [0, 0, 1], [-1, 0, 0], [0, -1, 0], [0, 0, -1]], faces=[[0, 2, 1], [0, 5, 1], [0, 4, 2], [0, 5, 4], [1, 3, 2], [1, 5, 3], [2, 4, 3], [3, 5, 4]]);
// tetrahedron
polyhedron(points=[[1, 1, -1], [1, -1, 1], [-1, 1, 1], [-1, -1, -1]], faces=[[0, 2, 1], [0, 3, 1], [0, 3, 2], [1, 3, 2]]);

}

module rod(a, b, r) {
    dir = b-a;
    h   = norm(dir);
    if(dir[0] == 0 && dir[1] == 0) {
        if (a[2]<b[2])        translate(a) cylinder(r=r, h=h);
        else translate(b) cylinder(r=r, h=h);
    }
    else {
        w  = dir / h;
        u0 = cross(w, [0,0,1]);
        u  = u0 / norm(u0);
        v0 = cross(w, u);
        v  = v0 / norm(v0);
        multmatrix(m=[[u[0], v[0], w[0], a[0]],
                      [u[1], v[1], w[1], a[1]],
                      [u[2], v[2], w[2], a[2]],
                      [0,    0,    0,    1]])
        cylinder(r=r, h=h);
    }
}

